% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AmbergRegister.r
\name{AmbergRegister}
\alias{AmbergRegister}
\title{Register two triangular meshes based on smooth deformation.}
\usage{
AmbergRegister(
  x,
  mesh2,
  lm1 = NULL,
  lm2 = NULL,
  k = 1,
  lambda = 1,
  iterations = 15,
  rho = pi/2,
  dist = 2,
  border = FALSE,
  smooth = TRUE,
  smoothit = 1,
  smoothtype = "t",
  tol = 1e-10,
  useiter = TRUE,
  minclost = 50,
  distinc = 1,
  rigid = NULL,
  similarity = NULL,
  affine = NULL,
  tps = FALSE,
  pcAlign = FALSE,
  nn = 20,
  silent = FALSE,
  useConstrained = TRUE,
  forceLM = FALSE,
  visualize = FALSE,
  folder = NULL,
  noinc = FALSE,
  angclost = FALSE,
  bboxCrop = NULL,
  threads = 0
)
}
\arguments{
\item{x}{reference mesh: triangular mesh of class "mesh3d"or of class BayesDeform created by createBayes to restrict based on a known distribution. To use this option the package RvtkStatismo \url{https://github.com/zarquon42b/RvtkStatismo} has to be installed.No loose vertices, edges and degenerated faces are allowed.}

\item{mesh2}{target mesh: triangular mesh of class "mesh3d".}

\item{lm1}{m x 3 matrix containing correspondences on "mesh1".}

\item{lm2}{m x 3 matrix containing target correspondences on "mesh2".}

\item{k}{integer: parameter regularizing face normal distortion. Can be
vector of length(iterations) or single value.}

\item{lambda}{numeric: parameter regularizing faces's distortion. Can be
vector of length(iterations) or single value.}

\item{iterations}{integer: number of iterations to run.}

\item{rho}{numeric: 0 < rho < 2*pi tolerance of normal deviation between
reference vertices and corresponding closest points on target suface.}

\item{dist}{numeric: tolerance of maximal distance between reference
vertices and corresponding closest points on target suface.}

\item{border}{logical: if FALSE, hits on border faces are ignored (reduces
distortion)}

\item{smooth}{logical: if TRUE after each iteration a mesh smoothing is performed.}

\item{smoothit}{integer: determine smoothing iterations.}

\item{smoothtype}{character: select smoothing algorithm - see vcgSmooth for further details.}

\item{tol}{numeric: convergence threshold of MSE between vertices of two
successive iterations.}

\item{useiter}{logical: if TRUE, each iteration uses the updated reference
mesh, if false. The original mesh will be deformed based on the updated
correspondences.}

\item{minclost}{minimum amount of correspondence points. If less
correspondences are found, dist will be increased by "distinc" (see below).}

\item{distinc}{increment of dist, in case minclost is not reached.}

\item{rigid}{named list. Passing parameters to \code{\link{icp}}, for rigid registration. If landmarks are provided and only those should count, set rigid$iterations=0.}

\item{similarity}{named list. Passing parameters to \code{\link{icp}}, for similarity registration (rigid +scaling). If landmarks are provided and only those should count, set similarity$iterations=0 (and rigid=NULL).}

\item{affine}{named list. Passing parameters to \code{\link{icp}}, for affine registration. If landmarks are provided and only those should count, set similarity$iterations=0 (with rigid=NULL and similarity=NULL)}

\item{tps}{logical: if TRUE and landmarks are provided, the reference will be mapped to the target using a Thin-Plate Spline interpolation. Overrides \code{rigid},\code{affine} and \code{similarity}.}

\item{pcAlign}{if TRUE, surfaces are prealigned by principal axis. Overrides intial landmark based alignment.}

\item{nn}{integer: closest barycenters. During search for closest points on target, the closest \code{nn} faces are probed. The larger \code{nn} is , the more accurate the closest point search but also the more time consuming. If landmarks are provided and only those should count, set rigid$iterations=0.}

\item{silent}{logical: no verbosity}

\item{useConstrained}{logical: if TRUE and Bayes and landmarks are defined, the landmarks are not only used to get a suitable reference but the model will also be constrained by the landmarks to subsequently restrict the shape variability. If FALSE, the full model is used.}

\item{forceLM}{logical: if icp is requested landmark based deformation will be applied after icp-based transformation.}

\item{visualize}{logical request visualization of deformation process.}

\item{folder}{logical: if visualize=TRUE, this can specify a folder to save screenshots of each deformation state, in order to create a movie or an animated gif.}

\item{noinc}{logical: if TRUE and x is of class 'Bayes', the process stops if the distance from the target to the deformed reference increases compared to the previous iteration.}

\item{angclost}{if TRUE, the closest k faces will be evaluated and the closest with the appropriate normal angle will be selected.}

\item{bboxCrop}{extend of the bounding box around mesh1 (after alignmend) that will be cropped from target to speed things up.}

\item{threads}{integer: threads to use in closest point search.}
}
\value{
\item{mesh}{registered mesh}
\item{affine }{affine 4x4 transformation matrix mapping mesh1 onto mesh2}
\item{lm1 }{lm1 mapped onto the registered template}
}
\description{
Perform registration of two triangular meshes, minimizing per-face
distortions.
}
\details{
This function runs an elastic-ICP surface matching algorithm, that minimizes the original meshes internal structure by solving a sparse equation system. The user can control 2 parameters of mesh stiffness: \code{lambda} and \code{k}. \code{lambda} controls the impact of the control points (closest points) as it is a weight applied to the equation system. The value of \code{lambda} should be carefully selected depending on the object overall size: i.e. to match two tiny meshes one will need a higher value than a for a larger object (example: I found values between 0 and 1 suitable for human faces and values between 10 and 100 suitable for mice teeth). \code{k} controls the normal slackness, i.e. the deviation of normal direction. The larger, \code{k}, the more elastic the deformation will be. \code{lambda} and \code{k} can be specified as vectors of length \code{iterations}, to assign a specific value for each iteration.
}
\examples{
require(Morpho)

require(Rvcg)
data(humface)
data(dummyhead)
## set parameters making each iteration more elastic
# only 10 iterations to keep example calculation time reasonable.
params <- list(iterations=10) 
params <- append(params, list(
   # first lambda is set relatively high because first matching uses landmarks
   # then let it increase from 0.2 to 0.6
   lambda=c(0.7,seq(from = 0.2,to=0.6,length.out = params$iterations-1)),
   # treat k similar as lambda
   k=c(10,seq(from = 1,to=params$iterations-1,by=1)),
   useiter=FALSE # iteratively deform dummyhead onto humface
   ))
#we also want the landmarks to be used in an initial similarity transform
similarity <- list(iterations=0)
map <- AmbergRegister(dummyhead.mesh, humface, lm1=dummyhead.lm,
                 lm2=humface.lm, iterations=params$iterations,similarity=similarity,
                 k=params$k, lambda=params$lambda, useiter=params$useiter)
# compare matched and original face:
\dontrun{
require(rgl)
meshDist(map$mesh, humface ,from=-3,to=3,tol=0.5)
# render original mesh as wireframe
shade3d(humface,front="lines",back="lines")
}
##example with different icp matchings:
rigid <- list(iterations=30,subsample=200,rhotol=pi/2,uprange=0.6)
similarity <- list(iterations=30, subsample=200,rhotol=pi/2,uprange=0.6)
affine <- list(iterations=30,subsample=200,rhotol=pi/2,uprange=0.6)
map <- AmbergRegister(dummyhead.mesh, humface, lm1=dummyhead.lm,
                      lm2=humface.lm, iterations=params$iterations,
                      k=params$k, lambda=params$lambda, useiter=params$useiter,rigid=rigid,
                      similarity=similarity,affine=affine,forceLM = TRUE)
}
\references{
Amberg, B. 2011. Editing faces in videos, University of Basel.
}
\seealso{
\code{\link{gaussMatch}}
}
\author{
Stefan Schlager
}
