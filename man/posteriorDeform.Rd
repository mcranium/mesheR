% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/posteriorDeform.r
\name{posteriorDeform}
\alias{posteriorDeform}
\title{Fit an SSM to a target based on subsampling corresponding points}
\usage{
posteriorDeform(
  model,
  target,
  reference = NULL,
  partsample = NULL,
  samplenum = 1000,
  distance = 1e+10,
  slide = 3,
  bending = TRUE,
  ray = FALSE,
  deform = FALSE,
  Amberg = FALSE,
  rhotol = pi/2,
  modlm = NULL,
  tarlm = NULL,
  align2mod = TRUE,
  alignbymesh = FALSE,
  forceLM = FALSE,
  silent = FALSE,
  threads = 1
)
}
\arguments{
\item{model}{statismo shape model}

\item{target}{target mesh}

\item{reference}{model instance other than the mean (class mesh3d)}

\item{partsample}{predetermined corresponding points on the sample mean}

\item{samplenum}{integer: if partsample=NULL, this specifies the number of coordinates sampled on the model mean}

\item{distance}{numeric: constrain maximum distance to mark target point as appropriate}

\item{slide}{integer: if > 0 the valid correspondences on the model instance will be relaxed minimizing bending energy/procrustes distance.}

\item{bending}{logical: if TRUE, the coordinates on the model instance are relaxed using bending energy, Procrustes distance otherwise}

\item{ray}{logical: if TRUE, the closest point search will be performed along the normals only}

\item{deform}{logical if TRUE, the posterior mean will also be deformed to the target using an elastic deformation}

\item{Amberg}{if TRUE the deformation will use the function \code{\link{AmbergDeformSpam}} and \code{\link{tps3d}} otherwise}

\item{rhotol}{maximal tolerated angle between normals to be considered a valid match}

\item{modlm}{matrix containing 3D landmarks on the model mean (not for alignment)}

\item{tarlm}{matrix containing 3D landmarks on the target surface}

\item{align2mod}{logical: if TRUE, the prediction step will perform an alignment to the model using the valid correspondences.}

\item{alignbymesh}{logical: if TRUE, the alignment to the SSM will be computed by the entire mesh, if FALSE only the valid correspondences are used.}

\item{forceLM}{if TRUE, predfined landmarks \code{modlm} are not allowed to slide. For cases with high uncertainty, this can lead to unwanted mesh distortions.}

\item{silent}{logical: supress debug output}

\item{threads}{integer: number of threads to use for tps interpolation (set to 1 if using openblas, or otherwise it can become instable)}
}
\value{
returns a deformed version of a model instance fitted to the target
}
\description{
Fit an SSM to a target based on subsampling corresponding points and compute the posterior mean
}
\note{
Please note that it is required to align the target mesh to the model mean beforehand. This can be performed using the function \code{\link{icp}}, for example.
}
\examples{
\dontrun{
require(RvtkStatismo)
download.file(url="https://github.com/marcelluethi/statismo-shaperegistration/raw/master/data/VSD001_femur.vtk","./VSD001_femur.vtk",method = "w")
download.file(url="https://github.com/marcelluethi/statismo-shaperegistration/raw/master/data/VSD002_femur.vtk","./VSD002_femur.vtk",method = "w")
download.file(url="https://github.com/marcelluethi/statismo-shaperegistration/raw/master/data/VSD001-lm.csv","./VSD001-lm.csv",method = "w")
download.file(url="https://github.com/marcelluethi/statismo-shaperegistration/raw/master/data/VSD002-lm.csv","./VSD002-lm.csv",method = "w")
ref <- read.vtk("VSD001_femur.vtk")
tar <- read.vtk("VSD002_femur.vtk")
ref.lm <- as.matrix(read.csv("VSD001-lm.csv",row.names=1,header = FALSE))
tar.lm <- as.matrix(read.csv("VSD002-lm.csv",row.names=1,header = FALSE))
Kernels <- SumKernels(GaussianKernel(50,50),IsoKernel(0.1,ref))
mymod <- statismoModelFromRepresenter(ref,kernel=Kernels,ncomp=100)
postDef <- posteriorDeform(mymod,tar,modlm=ref.lm,tarlm = tar.lm,samplenum = 1000)
## run a loop redoing that step using the result of the previous step as input
for (i in 1:5)
   postDef <- posteriorDeform(mymod,tar,modlm=ref.lm,tarlm = tar.lm,samplenum = 1000,reference=postDef)

## now we leave the model space for a final deform involving a TPS deform
postDefFinal <- postDef
for (i in 1:3)
    postDefFinal <- posteriorDeform(mymod,tar,modlm=ref.lm,tarlm = tar.lm,samplenum = 3000,reference=postDefFinal,deform=T,distance=3)

Morpho::meshDist(postDefFinal,tar,from=-2,to=2,tol=.5)
rgl::wire3d(tar,col="white")
}
}
