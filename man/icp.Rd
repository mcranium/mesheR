% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/icp.r
\name{icp}
\alias{icp}
\title{Iterative closest point matching between two triangular meshes.}
\usage{
icp(
  mesh1,
  mesh2,
  iterations = 3,
  lm1 = NULL,
  lm2 = NULL,
  uprange = 1,
  maxdist = NULL,
  minclost = 50,
  distinc = 0.5,
  rhotol = pi,
  k = 50,
  reflection = FALSE,
  silent = FALSE,
  subsample = NULL,
  subsampletype = c("km", "pd"),
  type = c("rigid", "similarity", "affine"),
  getTransform = FALSE,
  pcAlign = FALSE,
  pcOptim = TRUE,
  threads = 0,
  weights = NULL
)
}
\arguments{
\item{mesh1}{object of class "mesh3d".}

\item{mesh2}{object of class "mesh3d".}

\item{iterations}{integer}

\item{lm1}{optional: kx3 matrix containing reference points on mesh1.}

\item{lm2}{optional: kx3 matrix containing reference points on mesh2.}

\item{uprange}{quantile of distances between vertices of mesh1 and closest
points on mesh2. All hit points on mesh2 farther away than the specified
quantile are not used for matching.}

\item{maxdist}{maximum distance for closest points to be included for matching. Overrides uprange, if specified.}

\item{minclost}{integer: only valid if maxdist is specified. If less than maxdist closest points are found, maxdist is increased by distinc (see below) until the specified number is reached.}

\item{distinc}{numeric: amount to increment maxdist until minclost points are within this disatnce.}

\item{rhotol}{maximum allowed angle of which normals are allowed to differ
between reference points and hit target points. Hit points above this
threshold will be neglected.}

\item{k}{integer: number of closest triangles on target that will be
searched for hits.}

\item{reflection}{logical: allow reflection.
closemeshKD from the package Morpho, while vcg calls vcgClostKD from Rvcg.
If the tow meshes have only little or no overlap, "vcg" can be really slow. Otherwise very fast. "morpho" is the stable but somewhat slower algorithm.}

\item{silent}{logical: no verbosity}

\item{subsample}{integer use a subsample (using kmeans clustering) to find closest points for  - subsample specifies the size of this subsample.}

\item{subsampletype}{select type of subsampling (see \code{vcgSample} for details)}

\item{type}{set type of affine transformation: options are "affine", "rigid" and "similarity" (rigid + scale)}

\item{getTransform}{logical: if TRUE, a list containing the transformed mesh and the 4x4 transformation matrix.}

\item{pcAlign}{if TRUE, surfaces are prealigned by principal axis. Overrides intial landmark based alignment.}

\item{pcOptim}{if TRUE, all posible alignments to the PC-Axes are evaluated and the one with the lowest LSE will be used. Can be time consuming for large meshes.}

\item{threads}{integer: threads to use in closest point search.}

\item{weights}{vector containing weights for inital landmark transform}
}
\value{
if \code{getTransform=FALSE}, the tranformed mesh1 is returned and otherwise a list containing

\item{mesh}{tranformed mesh1}
\item{transform}{4x4 transformation matrix}
}
\description{
performs rigid body transformations (and scaling if requested) to map a
reference mesh onto a target mesh
}
\details{
the registration is done by minimising squared distances between reference
vertices and closest points on the target surface (a.k.a. Procrustes
registration)
}
\examples{

require(Morpho)
data(nose)
longnose.mesh <- tps3d(shortnose.mesh,shortnose.lm,longnose.lm)
rotnose <- icp(longnose.mesh,shortnose.mesh,lm1=longnose.lm,lm2=shortnose.lm,rhotol=0.7,uprange=0.9)
\dontrun{
require(rgl)
shade3d(rotnose,col=2,alpha=0.7)
shade3d(shortnose.mesh,col=3,alpha=0.7)
}
}
\references{
Zhang Z. 1994. Iterative point matching for registration of
free-form curves and surfaces International Journal of Computer Vision
13:119-152.
}
\seealso{
\code{\link{rotmesh.onto}}, \code{\link{rotonto}}
}
\author{
Stefan Schlager
}
